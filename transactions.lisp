(in-package :cl-transactional)

(defvar *top-level-transaction* t)

(defun call-with-mutexes-down (locks thunk)
  (if (null locks)
      (cons (funcall thunk) t)
      (with-mutex ((car locks) :wait-p nil)
	(call-with-mutexes-down (cdr locks) thunk))))

(defun call-with-mutexes-spinning (locks thunk)
  (iter (for down-lock next (call-with-mutexes-down locks thunk))
	(until (consp down-lock))
	(thread-yield)
	(finally (return (car down-lock)))))

(defmacro with-mutexes-spinning (locks &body body)
  `(call-with-mutexes-spinning ,locks
			       #'(lambda ()
				   ,@body)))

(defgeneric execute-transaction (transaction-log)
  (:method ((transaction-log hash-table))
    (let ((locks (iter (for (tvar nil) in-hashtable transaction-log)
		       (collecting (lock-of tvar)))))
      (with-mutexes-spinning locks
	(if (iter (for (tvar tvar-log) in-hashtable transaction-log)
		  (always (eql (read-value-of tvar-log)
			       (value-of tvar))))
	    (iter (for (tvar tvar-log) in-hashtable transaction-log)
		  (unless (eql (write-value-of tvar-log)
			       (value-of tvar))
		    (setf (value-of tvar) (write-value-of tvar-log))
		    (notify-waitees tvar))
		  (finally (return t))))))))

(defcondition* transaction-fail ()
  ((transaction-log nil)))

(defun retry-transaction ()
  (signal 'transaction-fail :transaction-log *transaction-log*))

(defgeneric suspend-thread-on-tvars (fail-tvars)
  (:method ((fail-tvars list))
    (unless (null fail-tvars)
     (let ((wait-mutex (make-mutex))
	   (wait-queue (make-waitqueue)))
       (with-mutex (wait-mutex)
	 (iter (for tvar in fail-tvars)
	       (with-mutex ((lock-of tvar))
		 (push (list wait-mutex wait-queue fail-tvars)
		       (waiting-of tvar))))
	 (condition-wait wait-queue wait-mutex))))
    (values nil nil)))

(defun call-with-transaction (thunk)
  (let ((*transaction-log* (if *top-level-transaction*
			       (make-hash-table)
			       *transaction-log*))
	(*top-level-transaction* nil))
    (let ((transaction-result (funcall thunk)))
      (if (execute-transaction *transaction-log*)
	  (values transaction-result t)
	  (signal 'transaction-fail)))))

(defmacro with-retry-transaction (&body body)
  (with-unique-names (thunk t-result t-success)
    `(let ((,thunk #'(lambda ()
		      ,@body)))
       (if (null *top-level-transaction*)
	   (funcall ,thunk)
	   (iter (for (values ,t-result ,t-success) next
		      (handler-case (call-with-transaction ,thunk)
			(transaction-fail (fail-condition)
			  (aif (transaction-log-of fail-condition)
			       (suspend-thread-on-tvars (hash-table-keys it))
			       (values nil nil)))))
		 (until ,t-success)
		 (finally (return ,t-result)))))))

(defun merge-logs-tvars (logs)
  (iter (for tvar in (iter (for l in logs)
			   (nconcing (hash-table-keys l))))))

(defun orelse-cycle (thunks)
  (iter (for thunk in thunks)
	(multiple-value-bind (t-result t-success)
	    (handler-case (values (call-with-transaction thunk) t)
	      (transaction-fail (fail-condition)
		(awhen (transaction-log-of fail-condition)
		  (collect it into fail-logs))
		(values nil nil)))
	  (awhen t-success
	    (leave (values t-result t))))
	(finally (suspend-thread-on-tvars (merge-logs-tvars fail-logs))
		 (return (values nil nil)))))

(defmacro with-orelse-transaction (&body body)
  (with-unique-names (thunks t-result t-success)
    `(let ((,thunks (list ,@(iter (for th in body)
				  (collecting `#'(lambda ()
						   ,@th))))))
       (assert *top-level-transaction*)
       (iter (for (values ,t-result ,t-success) next (orelse-cycle ,thunks))
	     (until ,t-success)
	     (finally (return ,t-result))))))
